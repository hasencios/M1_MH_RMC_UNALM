---
# Please do not edit this file directly; it is auto generated.
title: "Descarga de las salidas de los GCM"
teaching: 45
exercises: 375
questions:
- "¿Cómo automatizar la descarga de las salidas de los GCM?"
objectives:
- "Describir el procedimiento para la descarga de las salidas de los GCM"
keypoints:
- "Python es muy potente para automatizar la descarga sistemática de datos."
source: Rmd
---

<!--

Los datos climáticos que necesitamos están disponibles a través de la **Earth System Grid Federation** (ESGF), una red  de centros académicos y gubernamentales en los Estados Unidos, Europa y Asia. Es un repositorio para todos los datos climáticos del CMIP5 y la flamante CMIP6. En este laboratorio, nos centraremos en la salida de datos del CMIP5.

El ESGF es una red de nodos. Por ejemplo, si visita esta página web del [ESGF](https://esgf-node.llnl.gov/projects/esgf-llnl/), estará visitando el nodo del Lawrence-Livermore National Laboratory, pero podría, teóricamente, elegir cualquiera de los otros nodos que aparecen en la página principal del ESGF.

## Realizar una consulta de las salidas de los GCM

El ESGF tiene una interfaz de búsqueda muy intuitiva, pero en su lugar, usaremos el paquete [esgf-pyclient](https://github.com/ESGF/esgf-pyclient), que proporciona una forma fácil de acceder a la API de búsqueda del ESGF directamente en Python.

 - Primero, importaremos las bibliotecas que necesitaremos. Específicamente, importaremos **pyesgf**, que es el nombre del módulo contenido en la biblioteca **esgf-pyclient**. Importaremos tanto las funciones de búsqueda como las de inicio de sesión. También importaremos **os**, **requests**, y **tqdm**, que usaremos en una función de descarga de archivos personalizados, que verán más adelante. Finalmente, usaremos **pandas** para crear una tabla desde la que leeremos nuestros resultados.

~~~
# Cargamos los paquetes
from pyesgf.search import SearchConnection
import os
import pandas as pd
import requests
from tqdm import tqdm
~~~
{: .language-python}

Inicie su búsqueda creando un nuevo objeto `SearchConnection`. Aquí indicaremos que queremos utilizar el nodo LLNL como punto de partida, y pediremos que nuestra búsqueda se distribuya a través de la red federada.

~~~
# Iniciamos la conexión con el servidor
conn = SearchConnection('https://esgf-node.llnl.gov/esg-search', distrib=True)
~~~
{: .language-python}

Ahora tenemos que proporcionar los criterios de búsqueda. El API del ESGF utiliza una serie de palabras clave definidas para encontrar los datos que está buscando. Las opciones que nos interesan se resumen en la siguiente tabla.

Nos interesan tres variables de temperatura y una de precipitación en este laboratorio: "tas", que es la Temperatura del Aire Cercana la Superficie; "tasmax", que es la Temperatura Máxima Diaria del Aire Cercana a la Superficie; "tasmin", la Temperatura Mínima Diaria del Aire Cercano a la Superficie; y "pr" que es la precipitatión en todas sus formas.

### Busqueda de los datos

 - Pasemos los criterios anteriores a nuestra función de búsqueda. Tengan en cuenta que también pasamos latest=True, lo que significa que queremos la última versión de cada conjunto de datos.
 
~~~
# Consulta del modelo CanESM2
query = conn.new_context(
    latest=True,
    facets='null', 
    project='CMIP5',
    model='CanESM2',
    experiment='historical,rcp26,rcp45,rcp60,rcp85',
    variable='pr,prc,tas,tasmax,tasmin',
    time_frequency="mon",
    realm='atmos',
    ensemble='r1i1p1')
~~~
{: .language-python}

y ejecutamos la busqueda.

~~~
results = query.search()
~~~
{: .language-python}

Puedes saber cuántos resultados ha obtenido tu búsqueda comprobando la longitud de `results`. También puedes obtener la propiedad `hit_count` del objeto de la consulta antes de buscar.

~~~
print(len(results))
~~~
{: .language-python}

~~~
15
~~~
{: .output}

~~~
print(query.hit_count)
~~~
{: .language-python}

~~~
15
~~~
{: .output}

~~~
print(query.hit_count == len(results))
~~~
{: .language-python}

~~~
True
~~~
{: .output}

Los resultados de la búsqueda contienen objetos de "contexto", que aún no nos dan la información que necesitamos. Procesemos el primer `hit`, para ver cómo el `esgf-pyclient` devuelve los resultados.

La información sobre los resultados se almacena en una propiedad de objeto llamada `json`. Puedes ver todos los detalles usando `results.json`. No imprimiremos el resultado completo aquí, pero podemos ver porciones del resultado.

Veamos el identificador del resultado.

~~~
print(results[0].json['id'])
~~~
{: .language-python}

~~~
cmip5.output.CCCma.CanESM2.rcp85.mon.atmos.r1i1p1.v20130331|crd-esgf-drc.ec.gc.ca
~~~
{: .output}

Este es un registro de la salida general del CMIP5, pero no es algo que podamos descargar directamente. Francamente, probablemente no queramos descargarlo de todas formas. Veamos las variables para las que el registro tiene datos.

~~~
print(results[0].json['variable'])
~~~
{: .language-python}

~~~
['ccb', 'cct', 'ci', 'cl', 'cli', 'clivi', 'clt', 'clw', 'clwvi', 'co2', 'co2mass', 'evspsbl', 'fco2antt', 'fco2nat', 'hfls', 'hfss', 'hur', 'hurs', 'hus', 'huss', 'mc', 'pr', 'prc', 'prsn', 'prw', 'ps', 'psl', 'rlds', 'rldscs', 'rlus', 'rlut', 'rlutcs', 'rsds', 'rsdscs', 'rsdt', 'rsus', 'rsuscs', 'rsut', 'rsutcs', 'rtmt', 'sbl', 'sci', 'sfcWind', 'ta', 'tas', 'tasmax', 'tasmin', 'tauu', 'tauv', 'tro3', 'ts', 'ua', 'uas', 'va', 'vas', 'wap', 'zg']
~~~
{: .output}

¡Eso es demasiado! No queremos acceder a la información de todas las variables. Sólo queremos `tas`, `tasmax`, `tasmin` y `pr`. Podemos profundizar en el registro solicitando una búsqueda adicional usando el file_context del registro como entrada para la búsqueda.

~~~
hit = results[0].file_context().search()
~~~
{: .language-python}

Esto debería devolver ahora un resultado por cada archivo del registro principal. Podemos ver cuántos registros tenemos.

~~~
print(len(hit))
~~~
{: .language-python}

~~~
57
~~~
{: .output}

Podemos usar una función anónima `lambda` para extraer el nombre de archivo y la URL de cada resultado.

~~~
files = map(lambda f : {'filename': f.filename, 'url': f.download_url}, hit)
~~~
{: .language-python}

La función `map` devuelve un iterador de clase `map`. Volvamos a convertirlo en una lista.

~~~
files = list(files)
~~~
{: .language-python}

Puedes echar un vistazo a los primeros cinco registros.

~~~
print(files[0:10])
~~~
{: .language-python}

~~~
[{'filename': 'ccb_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/ccb/r1i1p1/ccb_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'cct_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/cct/r1i1p1/cct_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'ci_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/ci/r1i1p1/ci_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'cl_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/cl/r1i1p1/cl_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'cli_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/cli/r1i1p1/cli_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'clivi_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/clivi/r1i1p1/clivi_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'clt_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/clt/r1i1p1/clt_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'clw_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/clw/r1i1p1/clw_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'clwvi_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/clwvi/r1i1p1/clwvi_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'co2_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/co2/r1i1p1/co2_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}]
~~~
{: .output}

Todavía tenemos información sobre variables que no nos interesan. Dejemos los items que no nos interesan. Ten en cuenta que el filtro devuelve un iterador que no es una lista, así que terminaremos la llamada al filtro en lista.

~~~
var = 'tas' # pr_
~~~
{: .language-python}

~~~
files = list(filter(lambda x: var in x['filename'], files))
print(files)
~~~
{: .language-python}

~~~
[{'filename': 'tas_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/tas/r1i1p1/tas_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'tasmax_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/tasmax/r1i1p1/tasmax_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}, {'filename': 'tasmin_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/rcp85/mon/atmos/tasmin/r1i1p1/tasmin_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc'}]
~~~
{: .output}

Repitamos este proceso para el segundo resultado de nuestra búsqueda original. En lugar de ejecutar cada línea individualmente, podemos colapsar esto en una sola llamada.

~~~
files2 = list(filter(lambda x: var in x['filename'],
                     list(map(lambda f : {'filename': f.filename, 'url': f.download_url},
                              results[1].file_context().search()))))
print(files2)
~~~
{: .language-python}

~~~
[{'filename': 'tas_Amon_CanESM2_historical_r1i1p1_185001-200512.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/historical/mon/atmos/tas/r1i1p1/tas_Amon_CanESM2_historical_r1i1p1_185001-200512.nc'}, {'filename': 'tasmax_Amon_CanESM2_historical_r1i1p1_185001-200512.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/historical/mon/atmos/tasmax/r1i1p1/tasmax_Amon_CanESM2_historical_r1i1p1_185001-200512.nc'}, {'filename': 'tasmin_Amon_CanESM2_historical_r1i1p1_185001-200512.nc', 'url': 'http://crd-esgf-drc.ec.gc.ca/thredds/fileServer/esg_dataroot/AR5/CMIP5/output/CCCma/CanESM2/historical/mon/atmos/tasmin/r1i1p1/tasmin_Amon_CanESM2_historical_r1i1p1_185001-200512.nc'}]
~~~
{: .output}

Ahora vamos a añadir files2 al final de los files. No es que esta función sea una función en sí, modificando los files directamente sin necesidad de sobrescribir el objeto asignando un valor a los files con un signo igual.

~~~
files.extend(files2)
~~~
{: .language-python}

Dos resultados menos, `python len(results) - 2` - ¡Quedan 2! Esto podría ser tedioso. Usemos un `for` de for para hacer el resto del trabajo por nosotros.

~~~
for i in range(2, len(results)):
    files.extend(list(filter(lambda x: var in x['filename'],
                      list(map(lambda f : {'filename': f.filename, 'url': f.download_url},
                               results[i].file_context().search())))))
~~~
{: .language-python}

### Sistematizando los resultados

Hasta ahora, hemos estado usando una lista de diccionarios para almacenar nuestros resultados, pero esto se está volviendo un poco difícil de manejar. Convirtamos nuestros resultados en un marco de datos de `Pandas`.

~~~
files = pd.DataFrame.from_dict(files)
print(files)
~~~
{: .language-python}

~~~
                                             filename  \
0      tas_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc   
1   tasmax_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc   
2   tasmin_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc   
3   tas_Amon_CanESM2_historical_r1i1p1_185001-2005...   
4   tasmax_Amon_CanESM2_historical_r1i1p1_185001-2...   
..                                                ...   
61  tasmin_Amon_CanESM2_rcp45_r1i1p1_200601-210012.nc   
62  tasmin_Amon_CanESM2_rcp45_r1i1p1_210101-230012.nc   
63     tas_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc   
64  tasmax_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc   
65  tasmin_Amon_CanESM2_rcp85_r1i1p1_200601-210012.nc   

                                                  url  
0   http://crd-esgf-drc.ec.gc.ca/thredds/fileServe...  
1   http://crd-esgf-drc.ec.gc.ca/thredds/fileServe...  
2   http://crd-esgf-drc.ec.gc.ca/thredds/fileServe...  
3   http://crd-esgf-drc.ec.gc.ca/thredds/fileServe...  
4   http://crd-esgf-drc.ec.gc.ca/thredds/fileServe...  
..                                                ...  
61  http://esgf.nci.org.au/thredds/fileServer/repl...  
62  http://esgf.nci.org.au/thredds/fileServer/repl...  
63  http://esgf.nci.org.au/thredds/fileServer/repl...  
64  http://esgf.nci.org.au/thredds/fileServer/repl...  
65  http://esgf.nci.org.au/thredds/fileServer/repl...  

[66 rows x 2 columns]
~~~
{: .output}

Podemos eliminar las proyecciones de largo alcance (2101-2300) de nuestra lista de descargas.

~~~
files = files[~files['filename'].str.contains("210101")]
~~~
{: .language-python}

Notarán que tenemos múltiples URLs para el mismo archivo. No es necesario que descarguemos cada archivo varias veces, por lo que puedes optar por soltar los duplicados utilizando `files[['nombre de archivo']].drop_duplicates()`.

También puedes optar por conservar las URL adicionales como fuentes de respaldo en caso de que una de las descargas falle. Nuestra función de descarga, a continuación, contiene un código para comprobar si el tamaño del archivo es el esperado, sin embargo, actualmente no incluye ningún código para manejar los casos en los que el tamaño no es el correcto.

## Descargando la información

**Python** no tiene una función de descarga de archivos incorporada, así que podemos usar la nuestra. Define la siguiente función, que descargará los archivos de una URL dada y los guardará bajo el nombre de archivo que especifiques.

~~~
# Adapted from: https://stackoverflow.com/a/37573701
def download(url, filename):
    print("Downloading ", filename)
    r = requests.get(url, stream=True)
    total_size, block_size = int(r.headers.get('content-length', 0)), 1024
    with open(filename, 'wb') as f:
        for data in tqdm(r.iter_content(block_size),
                         total=total_size//block_size,
                         unit='KiB', unit_scale=True):
            f.write(data)
            
    if total_size != 0 and os.path.getsize(filename) != total_size:
        print("Downloaded size does not match expected size!\n",
              "FYI, the status code was ", r.status_code)
~~~
{: .language-python}

Ahora puedes descargar un archivo como el siguiente:

~~~
download(files[0]['url'], files[0]['filename'])
~~~
{: .language-python}

O podrías descargarlos todos de una sola vez. 

~~~
for index, row in files.iterrows():
    if os.path.isfile(row.filename):
        print("File exists. Skipping.")
    else:
        download(row.url, row.filename)
~~~
{: .language-python}

Ahora que sabes cómo buscar y filtrar datos, practica con diferentes conjuntos de filtros, y luego completa los ejercicios, a continuación.

{% include links.md %}

-->